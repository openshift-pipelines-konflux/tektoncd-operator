From 6605dffd90997304fb67d5b11734230ce3995933 Mon Sep 17 00:00:00 2001
From: Pramod Bindal <prbindal@redhat.com>
Date: Wed, 12 Mar 2025 16:19:19 +0530
Subject: [PATCH 1/2] Add TektonPruner component in Operator

---
 .../tekton-operator/templates/deployment.yaml |   2 +-
 charts/tekton-operator/values.yaml            |   2 +-
 components.yaml                               |   3 +
 .../300-operator_v1alpha1_pruner_crd.yaml     |  51 +++
 config/base/kustomization.yaml                |   1 +
 config/crs/kubernetes/kustomization.yaml      |   1 +
 .../pruner/operator_v1alpha1_pruner_cr.yaml   |  20 +
 config/crs/openshift/kustomization.yaml       |   1 +
 .../pruner/operator_v1alpha1_pruner_cr.yaml   |  20 +
 config/kubernetes/base/operator.yaml          |   4 +-
 config/openshift/base/operator.yaml           |   2 +-
 hack/fetch-releases.sh                        |  57 +++
 operatorhub/openshift/config.yaml             |   7 +
 ...nes-operator-rh.clusterserviceversion.yaml |   4 +
 pkg/apis/operator/v1alpha1/const.go           |   2 +-
 pkg/apis/operator/v1alpha1/register.go        |   5 +
 .../v1alpha1/tektonpruner_lifecycle.go        | 156 +++++++
 .../operator/v1alpha1/tektonpruner_types.go   |  80 ++++
 .../v1alpha1/zz_generated.deepcopy.go         | 113 +++++
 .../v1alpha1/fake/fake_operator_client.go     |   4 +
 .../v1alpha1/fake/fake_tektonpruner.go        | 132 ++++++
 .../operator/v1alpha1/generated_expansion.go  |   2 +
 .../operator/v1alpha1/operator_client.go      |   5 +
 .../typed/operator/v1alpha1/tektonpruner.go   | 184 ++++++++
 .../informers/externalversions/generic.go     |   2 +
 .../operator/v1alpha1/interface.go            |   7 +
 .../operator/v1alpha1/tektonpruner.go         |  89 ++++
 .../v1alpha1/tektonpruner/fake/fake.go        |  40 ++
 .../tektonpruner/filtered/fake/fake.go        |  52 +++
 .../tektonpruner/filtered/tektonpruner.go     |  65 +++
 .../v1alpha1/tektonpruner/tektonpruner.go     |  52 +++
 .../v1alpha1/tektonpruner/controller.go       | 170 +++++++
 .../v1alpha1/tektonpruner/reconciler.go       | 432 ++++++++++++++++++
 .../operator/v1alpha1/tektonpruner/state.go   |  97 ++++
 .../operator/v1alpha1/expansion_generated.go  |   4 +
 .../listers/operator/v1alpha1/tektonpruner.go |  68 +++
 pkg/reconciler/common/initcontroller.go       |   3 +
 pkg/reconciler/common/releases.go             |   2 +
 pkg/reconciler/common/transformers.go         |   1 +
 .../kubernetes/kubernetesplatform/config.go   |   4 +
 .../kubernetes/tektonpruner/controller.go     |  92 ++++
 .../kubernetes/tektonpruner/finalizer.go      |  53 +++
 .../kubernetes/tektonpruner/reconciler.go     | 134 ++++++
 .../kubernetes/tektonpruner/transformer.go    |  51 +++
 .../openshift/openshiftplatform/config.go     |   4 +
 pkg/reconciler/platform/const.go              |   1 +
 46 files changed, 2276 insertions(+), 5 deletions(-)
 create mode 100644 config/base/300-operator_v1alpha1_pruner_crd.yaml
 create mode 100644 config/crs/kubernetes/pruner/operator_v1alpha1_pruner_cr.yaml
 create mode 100644 config/crs/openshift/pruner/operator_v1alpha1_pruner_cr.yaml
 create mode 100644 pkg/apis/operator/v1alpha1/tektonpruner_lifecycle.go
 create mode 100644 pkg/apis/operator/v1alpha1/tektonpruner_types.go
 create mode 100644 pkg/client/clientset/versioned/typed/operator/v1alpha1/fake/fake_tektonpruner.go
 create mode 100644 pkg/client/clientset/versioned/typed/operator/v1alpha1/tektonpruner.go
 create mode 100644 pkg/client/informers/externalversions/operator/v1alpha1/tektonpruner.go
 create mode 100644 pkg/client/injection/informers/operator/v1alpha1/tektonpruner/fake/fake.go
 create mode 100644 pkg/client/injection/informers/operator/v1alpha1/tektonpruner/filtered/fake/fake.go
 create mode 100644 pkg/client/injection/informers/operator/v1alpha1/tektonpruner/filtered/tektonpruner.go
 create mode 100644 pkg/client/injection/informers/operator/v1alpha1/tektonpruner/tektonpruner.go
 create mode 100644 pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner/controller.go
 create mode 100644 pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner/reconciler.go
 create mode 100644 pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner/state.go
 create mode 100644 pkg/client/listers/operator/v1alpha1/tektonpruner.go
 create mode 100644 pkg/reconciler/kubernetes/tektonpruner/controller.go
 create mode 100644 pkg/reconciler/kubernetes/tektonpruner/finalizer.go
 create mode 100644 pkg/reconciler/kubernetes/tektonpruner/reconciler.go
 create mode 100644 pkg/reconciler/kubernetes/tektonpruner/transformer.go

diff --git a/charts/tekton-operator/templates/deployment.yaml b/charts/tekton-operator/templates/deployment.yaml
index b67b9d3f1..336b5aaa9 100644
--- a/charts/tekton-operator/templates/deployment.yaml
+++ b/charts/tekton-operator/templates/deployment.yaml
@@ -68,7 +68,7 @@ spec:
               value: {{ include "tekton-operator.fullname" . }}-observability
           args:
             - "-controllers"
-            - {{ .Values.controllers | default "tektonconfig,tektonpipeline,tektontrigger,tektonhub,tektonchain,tektonresult,tektondashboard,manualapprovalgate" | quote }}
+            - {{ .Values.controllers | default "tektonconfig,tektonpipeline,tektontrigger,tektonhub,tektonchain,tektonresult,tektondashboard,manualapprovalgate,tektonpruner" | quote }}
             - "-unique-process-name"
             - "tekton-operator-lifecycle"
           image: {{ include "tekton-operator.operator-image" . }}
diff --git a/charts/tekton-operator/values.yaml b/charts/tekton-operator/values.yaml
index dc7ec2102..0a62095d7 100644
--- a/charts/tekton-operator/values.yaml
+++ b/charts/tekton-operator/values.yaml
@@ -14,7 +14,7 @@ openshift:
 installCRDs: false
 
 ## Controllers to install
-controllers: "tektonconfig,tektonpipeline,tektontrigger,tektonhub,tektonchain,tektonresult,tektondashboard,manualapprovalgate"
+controllers: "tektonconfig,tektonpipeline,tektontrigger,tektonhub,tektonchain,tektonresult,tektondashboard,manualapprovalgate,tektonpruner"
 
 ## Control the creation of RBAC resources (Serviceaccount, Role, ClusterRole, ClusterRoleBinding)
 rbac:
diff --git a/components.yaml b/components.yaml
index 86590a14f..ea0ca50c6 100644
--- a/components.yaml
+++ b/components.yaml
@@ -1,3 +1,6 @@
+tekton-pruner:
+  github: openshift-pipelines/tektoncd-pruner
+  version: v0.1.0
 chains:
   github: tektoncd/chains
   version: v0.24.0
diff --git a/config/base/300-operator_v1alpha1_pruner_crd.yaml b/config/base/300-operator_v1alpha1_pruner_crd.yaml
new file mode 100644
index 000000000..9f21873bb
--- /dev/null
+++ b/config/base/300-operator_v1alpha1_pruner_crd.yaml
@@ -0,0 +1,51 @@
+# Copyright 2020 The Tekton Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+apiVersion: apiextensions.k8s.io/v1
+kind: CustomResourceDefinition
+metadata:
+  name: tektonpruners.operator.tekton.dev
+  labels:
+    version: "devel"
+    operator.tekton.dev/release: "devel"
+spec:
+  group: operator.tekton.dev
+  names:
+    kind: TektonPruner
+    listKind: TektonPrunerList
+    plural: tektonpruners
+    singular: tektonpruner
+  preserveUnknownFields: false
+  scope: Cluster
+  versions:
+  - name: v1alpha1
+    served: true
+    storage: true
+    subresources:
+      status: {}
+    additionalPrinterColumns:
+      - jsonPath: .status.version
+        name: Version
+        type: string
+      - jsonPath: .status.conditions[?(@.type=="Ready")].status
+        name: Ready
+        type: string
+      - jsonPath: .status.conditions[?(@.type=="Ready")].message
+        name: Reason
+        type: string
+    schema:
+      openAPIV3Schema:
+        type: object
+        description: Schema for the tektonpruners API
+        x-kubernetes-preserve-unknown-fields: true
diff --git a/config/base/kustomization.yaml b/config/base/kustomization.yaml
index 6eb5d4e9d..e050bd2eb 100644
--- a/config/base/kustomization.yaml
+++ b/config/base/kustomization.yaml
@@ -23,6 +23,7 @@ resources:
 - 300-operator_v1alpha1_installer_set_crd.yaml
 - 300-operator_v1alpha1_hub_crd.yaml
 - 300-operator_v1alpha1_manualapprovalgate_crd.yaml
+- 300-operator_v1alpha1_pruner_crd.yaml
 - config-logging.yaml
 - config-observability.yaml
 - tekton-config-defaults.yaml
diff --git a/config/crs/kubernetes/kustomization.yaml b/config/crs/kubernetes/kustomization.yaml
index f6b7f4632..acf183ac2 100644
--- a/config/crs/kubernetes/kustomization.yaml
+++ b/config/crs/kubernetes/kustomization.yaml
@@ -10,3 +10,4 @@ resources:
 - chain/operator_v1alpha1_chain_cr.yaml
 - hub/operator_v1alpha1_hub_cr.yaml
 - manualapprovalgate/operator_v1alpha1_manualapprovalgate_cr.yaml
+- pruner/operator_v1alpha1_pruner_cr.yaml
diff --git a/config/crs/kubernetes/pruner/operator_v1alpha1_pruner_cr.yaml b/config/crs/kubernetes/pruner/operator_v1alpha1_pruner_cr.yaml
new file mode 100644
index 000000000..a43179b13
--- /dev/null
+++ b/config/crs/kubernetes/pruner/operator_v1alpha1_pruner_cr.yaml
@@ -0,0 +1,20 @@
+# Copyright 2020 The Tekton Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+apiVersion: operator.tekton.dev/v1alpha1
+kind: TektonPruner
+metadata:
+  name: pruner
+spec:
+  targetNamespace: tekton-pipelines
diff --git a/config/crs/openshift/kustomization.yaml b/config/crs/openshift/kustomization.yaml
index 6f9db22d4..9e6dbed45 100644
--- a/config/crs/openshift/kustomization.yaml
+++ b/config/crs/openshift/kustomization.yaml
@@ -9,5 +9,6 @@ resources:
 - pipelinesascode/operator_v1alpha1_openshiftpipelinesascode_cr.yaml
 - result/operator_v1alpha1_result_cr.yaml
 - manualapprovalgate/operator_v1alpha1_manualapprovalgate_cr.yaml
+- pruner/operator_v1alpha1_pruner_cr.yaml
 apiVersion: kustomize.config.k8s.io/v1beta1
 kind: Kustomization
diff --git a/config/crs/openshift/pruner/operator_v1alpha1_pruner_cr.yaml b/config/crs/openshift/pruner/operator_v1alpha1_pruner_cr.yaml
new file mode 100644
index 000000000..8a739ad58
--- /dev/null
+++ b/config/crs/openshift/pruner/operator_v1alpha1_pruner_cr.yaml
@@ -0,0 +1,20 @@
+# Copyright 2020 The Tekton Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+apiVersion: operator.tekton.dev/v1alpha1
+kind: TektonPruner
+metadata:
+  name: pruner
+spec:
+  targetNamespace: openshift-pipelines
diff --git a/config/kubernetes/base/operator.yaml b/config/kubernetes/base/operator.yaml
index 2ae167452..27b6f4acb 100644
--- a/config/kubernetes/base/operator.yaml
+++ b/config/kubernetes/base/operator.yaml
@@ -33,7 +33,7 @@ spec:
         image: ko://github.com/tektoncd/operator/cmd/kubernetes/operator
         args:
         - "-controllers"
-        - "tektonconfig,tektonpipeline,tektontrigger,tektonhub,tektonchain,tektonresult,tektondashboard,manualapprovalgate"
+        - "tektonconfig,tektonpipeline,tektontrigger,tektonhub,tektonchain,tektonresult,tektondashboard,manualapprovalgate,tektonpruner"
         - "-unique-process-name"
         - "tekton-operator-lifecycle"
         imagePullPolicy: Always
@@ -52,6 +52,8 @@ spec:
           value: ko://github.com/tektoncd/operator/cmd/kubernetes/proxy-webhook
         - name: IMAGE_JOB_PRUNER_TKN
           value: ghcr.io/tektoncd/plumbing/tkn@sha256:233de6c8b8583a34c2379fa98d42dba739146c9336e8d41b66030484357481ed
+        - name: IMAGE_PRUNER_CONTROLLER
+          value: quay.io/openshift-pipeline/pipelines-tektoncd-pruner-controller-rhel9:next
         - name: METRICS_DOMAIN
           value: tekton.dev/operator
         - name: VERSION
diff --git a/config/openshift/base/operator.yaml b/config/openshift/base/operator.yaml
index ffc9a42e7..647d649a8 100644
--- a/config/openshift/base/operator.yaml
+++ b/config/openshift/base/operator.yaml
@@ -38,7 +38,7 @@ spec:
         image: ko://github.com/tektoncd/operator/cmd/openshift/operator
         args:
         - "-controllers"
-        - "tektonconfig,tektonpipeline,tektontrigger,tektonhub,tektonchain,tektonaddon,tektonresult,openshiftpipelinesascode,manualapprovalgate"
+        - "tektonconfig,tektonpipeline,tektontrigger,tektonhub,tektonchain,tektonaddon,tektonresult,openshiftpipelinesascode,manualapprovalgate, tektonpruner"
         - "-unique-process-name"
         - "tekton-operator-lifecycle"
         imagePullPolicy: Always
diff --git a/hack/fetch-releases.sh b/hack/fetch-releases.sh
index 80c182a22..45fc18b28 100755
--- a/hack/fetch-releases.sh
+++ b/hack/fetch-releases.sh
@@ -112,6 +112,62 @@ release_yaml() {
     echo ""
 }
 
+# release_yaml_github <component>
+release_yaml_github() {
+  local github_component version releaseFileName destFileName component url
+
+  component=$1
+  echo fetching $component release yaml from github
+
+  github_component=$(yq .$component.github ${CONFIG})
+  version=$(yq .$component.version ${CONFIG})
+  releaseFileName=release-$version.yaml
+  destFileName=$releaseFileName
+
+  echo "$github_component version is $version"
+  case $version in
+    latest)
+      dirVersion=$(curl -sL https://api.github.com/repos/$github_component/releases | jq -r ".[].tag_name" | sort -Vr | head -n1)
+      ;;
+    *)
+      dirVersion=${version/v/}
+      ;;
+  esac
+  url="https://github.com/$github_component/releases/download/${version}/${releaseFileName}"
+  echo "URL to download Release YAML is : $url"
+
+    ko_data=${SCRIPT_DIR}/cmd/${TARGET}/operator/kodata
+    comp_dir=${ko_data}/${component}
+    dirPath=${comp_dir}/${dirVersion}
+
+    # destination file
+    dest=${dirPath}/${destFileName}
+    echo $dest
+
+    if [ -f "$dest" ] && [ $FORCE_FETCH_RELEASE = "false" ]; then
+      label="app.kubernetes.io/version: \"$version\""
+      label2="app.kubernetes.io/version: $version"
+      label3="version: \"$version\""
+      if grep -Eq "$label" $dest || grep -Eq "$label2" $dest || grep -Eq "$label3" $dest;
+      then
+          echo "release file already exist with required version, skipping!"
+          echo ""
+          return
+      fi
+    fi
+
+    # create a directory
+    mkdir -p ${dirPath} || true
+
+    http_response=$(curl -s -L -o ${dest} -w "%{http_code}" ${url})
+    if [[ $http_response != "200" ]]; then
+        echo "Error: failed to get $component yaml, status code: $http_response"
+        exit 1
+    fi
+    echo "Info: Added $component/$releaseFileName:$version release yaml !!"
+
+}
+
 # release_yaml_pac <component> <release-yaml-name> <version>
 release_yaml_pac() {
     echo fetching '|' component: ${1} '|' file: ${2} '|' version: ${3}
@@ -330,6 +386,7 @@ main() {
 
   # copy pruner rbac/sa yaml
   copy_pruner_yaml
+  release_yaml_github tekton-pruner
 
   echo updated payload tree
   find cmd/${TARGET}/operator/kodata
diff --git a/operatorhub/openshift/config.yaml b/operatorhub/openshift/config.yaml
index 3dc6c1abf..0ff2a8247 100644
--- a/operatorhub/openshift/config.yaml
+++ b/operatorhub/openshift/config.yaml
@@ -239,6 +239,13 @@ image-substitutions:
         envKeys:
           - IMAGE_MAG_TEKTON_TASKGROUP_CONTROLLER
           - IMAGE_MAG_MANUAL_APPROVAL
+- image: registry.redhat.io/openshift-pipelines/pipelines-tektoncd-pruner-controller-rhel9@
+  replaceLocations:
+    envTargets:
+      - deploymentName: openshift-pipelines-operator
+        containerName: openshift-pipelines-operator-lifecycle
+        envKeys:
+          - IMAGE_PRUNER_CONTROLLER
 - image: registry.redhat.io/openshift-pipelines/pipelines-pipelines-as-code-rhel9@
   replaceLocations:
     envTargets:
diff --git a/operatorhub/openshift/release-artifacts/bundle/manifests/openshift-pipelines-operator-rh.clusterserviceversion.yaml b/operatorhub/openshift/release-artifacts/bundle/manifests/openshift-pipelines-operator-rh.clusterserviceversion.yaml
index c5b7efded..06b2094f7 100644
--- a/operatorhub/openshift/release-artifacts/bundle/manifests/openshift-pipelines-operator-rh.clusterserviceversion.yaml
+++ b/operatorhub/openshift/release-artifacts/bundle/manifests/openshift-pipelines-operator-rh.clusterserviceversion.yaml
@@ -955,6 +955,8 @@ spec:
                   value: registry.redhat.io/openshift-pipelines/pipelines-manual-approval-gate-rhel9@
                 - name: IMAGE_MAG_MANUAL_APPROVAL
                   value: registry.redhat.io/openshift-pipelines/pipelines-manual-approval-gate-rhel9@
+                - name: IMAGE_PRUNER_CONTROLLER
+                  value: registry.redhat.io/openshift-pipelines/pipelines-tektoncd-pruner-controller-rhel9@
                 - name: IMAGE_PAC_PAC_CONTROLLER
                   value: registry.redhat.io/openshift-pipelines/pipelines-pipelines-as-code-rhel9@
                 - name: IMAGE_PAC_PAC_WEBHOOK
@@ -1189,6 +1191,8 @@ spec:
   - image: registry.redhat.io/openshift-pipelines/pipelines-manual-approval-gate-rhel9@
     name: IMAGE_MAG_MANUAL_APPROVAL
   - image: registry.redhat.io/openshift-pipelines/pipelines-pipelines-as-code-rhel9@
+    name: IMAGE_PRUNER_CONTROLLER
+  - image: registry.redhat.io/openshift-pipelines/pipelines-tektoncd-pruner-controller-rhel9@
     name: IMAGE_PAC_PAC_CONTROLLER
   - image: registry.redhat.io/openshift-pipelines/pipelines-pipelines-as-code-rhel9@
     name: IMAGE_PAC_PAC_WEBHOOK
diff --git a/pkg/apis/operator/v1alpha1/const.go b/pkg/apis/operator/v1alpha1/const.go
index 6268dbfd0..0269a52b6 100644
--- a/pkg/apis/operator/v1alpha1/const.go
+++ b/pkg/apis/operator/v1alpha1/const.go
@@ -138,5 +138,5 @@ var (
 	OperandTektoncdChains        = "tektoncd-chains"
 	OpenShiftPipelinesAsCodeName = "pipelines-as-code"
 	ManualApprovalGates          = "manual-approval-gate"
-	PrunerResourceName           = "tektoncd-pruner"
+	PrunerResourceName           = "pruner"
 )
diff --git a/pkg/apis/operator/v1alpha1/register.go b/pkg/apis/operator/v1alpha1/register.go
index a8f6c4a13..225ad6a49 100644
--- a/pkg/apis/operator/v1alpha1/register.go
+++ b/pkg/apis/operator/v1alpha1/register.go
@@ -61,6 +61,9 @@ const (
 
 	// KindManualApprovalGate is the Kind of KindManualApprovalGate in a GVK context.
 	KindManualApprovalGate = "ManualApprovalGate"
+
+	// KindTektonPruner is the Kind of KindTektonPruner in a GVK context.
+	KindTektonPruner = "TektonPruner"
 )
 
 // Resource takes an unqualified resource and returns a Group qualified GroupResource
@@ -94,6 +97,8 @@ func addKnownTypes(s *runtime.Scheme) error {
 		&OpenShiftPipelinesAsCodeList{},
 		&ManualApprovalGate{},
 		&ManualApprovalGateList{},
+		&TektonPruner{},
+		&TektonPrunerList{},
 	)
 	metav1.AddToGroupVersion(s, SchemeGroupVersion)
 	return nil
diff --git a/pkg/apis/operator/v1alpha1/tektonpruner_lifecycle.go b/pkg/apis/operator/v1alpha1/tektonpruner_lifecycle.go
new file mode 100644
index 000000000..40cf3a889
--- /dev/null
+++ b/pkg/apis/operator/v1alpha1/tektonpruner_lifecycle.go
@@ -0,0 +1,156 @@
+/*
+Copyright 2024 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package v1alpha1
+
+import (
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"knative.dev/pkg/apis"
+)
+
+var (
+	_ TektonComponentStatus = (*TektonPrunerStatus)(nil)
+
+	condSet = apis.NewLivingConditionSet(
+		DependenciesInstalled,
+		PreReconciler,
+		InstallerSetAvailable,
+		InstallerSetReady,
+		PostReconciler,
+	)
+)
+
+// GroupVersionKind returns SchemeGroupVersion of a TektonPruner
+func (pruner *TektonPruner) GroupVersionKind() schema.GroupVersionKind {
+	return SchemeGroupVersion.WithKind(KindTektonPruner)
+}
+
+func (pruner *TektonPruner) GetGroupVersionKind() schema.GroupVersionKind {
+	return SchemeGroupVersion.WithKind(KindTektonPruner)
+}
+
+// GetCondition returns the current condition of a given condition type
+func (pruner *TektonPrunerStatus) GetCondition(t apis.ConditionType) *apis.Condition {
+	return condSet.Manage(pruner).GetCondition(t)
+}
+
+// InitializeConditions initializes conditions of an TektonPrunerStatus
+func (pruner *TektonPrunerStatus) InitializeConditions() {
+	condSet.Manage(pruner).InitializeConditions()
+}
+
+// IsReady looks at the conditions returns true if they are all true.
+func (pruner *TektonPrunerStatus) IsReady() bool {
+	return condSet.Manage(pruner).IsHappy()
+}
+
+func (pruner *TektonPrunerStatus) MarkPreReconcilerComplete() {
+	condSet.Manage(pruner).MarkTrue(PreReconciler)
+}
+
+func (pruner *TektonPrunerStatus) MarkInstallerSetAvailable() {
+	condSet.Manage(pruner).MarkTrue(InstallerSetAvailable)
+}
+
+func (pruner *TektonPrunerStatus) MarkInstallerSetReady() {
+	condSet.Manage(pruner).MarkTrue(InstallerSetReady)
+}
+
+func (pruner *TektonPrunerStatus) MarkPostReconcilerComplete() {
+	condSet.Manage(pruner).MarkTrue(PostReconciler)
+}
+
+// MarkDependenciesInstalled marks the DependenciesInstalled status as true.
+func (pruner *TektonPrunerStatus) MarkDependenciesInstalled() {
+	condSet.Manage(pruner).MarkTrue(DependenciesInstalled)
+}
+
+func (pruner *TektonPrunerStatus) MarkNotReady(msg string) {
+	condSet.Manage(pruner).MarkFalse(
+		apis.ConditionReady,
+		"Error",
+		"Ready: %s", msg)
+}
+
+func (pruner *TektonPrunerStatus) MarkPreReconcilerFailed(msg string) {
+	pruner.MarkNotReady("PreReconciliation failed")
+	condSet.Manage(pruner).MarkFalse(
+		PreReconciler,
+		"Error",
+		"PreReconciliation failed with message: %s", msg)
+}
+
+func (pruner *TektonPrunerStatus) MarkInstallerSetNotAvailable(msg string) {
+	pruner.MarkNotReady("TektonInstallerSet not ready")
+	condSet.Manage(pruner).MarkFalse(
+		InstallerSetAvailable,
+		"Error",
+		"Installer set not ready: %s", msg)
+}
+
+func (pruner *TektonPrunerStatus) MarkInstallerSetNotReady(msg string) {
+	pruner.MarkNotReady("TektonInstallerSet not ready")
+	condSet.Manage(pruner).MarkFalse(
+		InstallerSetReady,
+		"Error",
+		"Installer set not ready: %s", msg)
+}
+
+func (pruner *TektonPrunerStatus) MarkPostReconcilerFailed(msg string) {
+	pruner.MarkNotReady("PostReconciliation failed")
+	condSet.Manage(pruner).MarkFalse(
+		PostReconciler,
+		"Error",
+		"PostReconciliation failed with message: %s", msg)
+}
+
+// MarkDependencyInstalling marks the DependenciesInstalled status as false with the
+// given message.
+func (pruner *TektonPrunerStatus) MarkDependencyInstalling(msg string) {
+	pruner.MarkNotReady("Dependencies installing")
+	condSet.Manage(pruner).MarkFalse(
+		DependenciesInstalled,
+		"Error",
+		"Dependency installing: %s", msg)
+}
+
+// MarkDependencyMissing marks the DependenciesInstalled status as false with the
+// given message.
+func (pruner *TektonPrunerStatus) MarkDependencyMissing(msg string) {
+	pruner.MarkNotReady("Missing Dependencies for TektonPruner")
+	condSet.Manage(pruner).MarkFalse(
+		DependenciesInstalled,
+		"Error",
+		"Dependency missing: %s", msg)
+}
+
+func (pruner *TektonPrunerStatus) GetTektonInstallerSet() string {
+	return pruner.TektonInstallerSet
+}
+
+func (pruner *TektonPrunerStatus) SetTektonInstallerSet(installerSet string) {
+	pruner.TektonInstallerSet = installerSet
+}
+
+// GetVersion gets the currently installed version of the component.
+func (pruner *TektonPrunerStatus) GetVersion() string {
+	return pruner.Version
+}
+
+// SetVersion sets the currently installed version of the component.
+func (pruner *TektonPrunerStatus) SetVersion(version string) {
+	pruner.Version = version
+}
diff --git a/pkg/apis/operator/v1alpha1/tektonpruner_types.go b/pkg/apis/operator/v1alpha1/tektonpruner_types.go
new file mode 100644
index 000000000..089dfdaea
--- /dev/null
+++ b/pkg/apis/operator/v1alpha1/tektonpruner_types.go
@@ -0,0 +1,80 @@
+/*
+Copyright 2024 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package v1alpha1
+
+import (
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	duckv1 "knative.dev/pkg/apis/duck/v1"
+)
+
+var (
+	_ TektonComponent     = (*TektonPruner)(nil)
+	_ TektonComponentSpec = (*TektonPrunerSpec)(nil)
+)
+
+// TektonPruner is the Schema for the TektonPruner API
+// +genclient
+// +genreconciler:krshapedlogic=false
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+// +genclient:nonNamespaced
+type TektonPruner struct {
+	metav1.TypeMeta   `json:",inline"`
+	metav1.ObjectMeta `json:"metadata,omitempty"`
+
+	Spec   TektonPrunerSpec   `json:"spec,omitempty"`
+	Status TektonPrunerStatus `json:"status,omitempty"`
+}
+
+type Pruner struct {
+	// options holds additions fields and these fields will be updated on the manifests
+	Options AdditionalOptions `json:"options"`
+}
+
+// TektonPrunerList contains a list of TektonPruner
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+type TektonPrunerList struct {
+	metav1.TypeMeta `json:",inline"`
+	metav1.ListMeta `json:"metadata,omitempty"`
+	Items           []TektonPruner `json:"items"`
+}
+
+type TektonPrunerSpec struct {
+	CommonSpec `json:",inline"`
+	Pruner     `json:",inline"`
+}
+
+// TektonPrunerStatus defines the observed state of TektonPruner
+type TektonPrunerStatus struct {
+	duckv1.Status `json:",inline"`
+
+	// The version of the installed release
+	// +optional
+	Version string `json:"version,omitempty"`
+
+	// The current installer set name for TektonPruner
+	// +optional
+	TektonInstallerSet string `json:"tektonInstallerSet,omitempty"`
+}
+
+// GetSpec implements TektonComponent
+func (in *TektonPruner) GetSpec() TektonComponentSpec {
+	return &in.Spec
+}
+
+func (in *TektonPruner) GetStatus() TektonComponentStatus {
+	return &in.Status
+}
diff --git a/pkg/apis/operator/v1alpha1/zz_generated.deepcopy.go b/pkg/apis/operator/v1alpha1/zz_generated.deepcopy.go
index 651882a17..f27c3cf13 100644
--- a/pkg/apis/operator/v1alpha1/zz_generated.deepcopy.go
+++ b/pkg/apis/operator/v1alpha1/zz_generated.deepcopy.go
@@ -1112,6 +1112,23 @@ func (in *Prune) DeepCopy() *Prune {
 	return out
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *Pruner) DeepCopyInto(out *Pruner) {
+	*out = *in
+	in.Options.DeepCopyInto(&out.Options)
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Pruner.
+func (in *Pruner) DeepCopy() *Pruner {
+	if in == nil {
+		return nil
+	}
+	out := new(Pruner)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *Resolvers) DeepCopyInto(out *Resolvers) {
 	*out = *in
@@ -2074,6 +2091,102 @@ func (in *TektonPipelineStatus) DeepCopy() *TektonPipelineStatus {
 	return out
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *TektonPruner) DeepCopyInto(out *TektonPruner) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
+	in.Spec.DeepCopyInto(&out.Spec)
+	in.Status.DeepCopyInto(&out.Status)
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TektonPruner.
+func (in *TektonPruner) DeepCopy() *TektonPruner {
+	if in == nil {
+		return nil
+	}
+	out := new(TektonPruner)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *TektonPruner) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *TektonPrunerList) DeepCopyInto(out *TektonPrunerList) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ListMeta.DeepCopyInto(&out.ListMeta)
+	if in.Items != nil {
+		in, out := &in.Items, &out.Items
+		*out = make([]TektonPruner, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TektonPrunerList.
+func (in *TektonPrunerList) DeepCopy() *TektonPrunerList {
+	if in == nil {
+		return nil
+	}
+	out := new(TektonPrunerList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *TektonPrunerList) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *TektonPrunerSpec) DeepCopyInto(out *TektonPrunerSpec) {
+	*out = *in
+	out.CommonSpec = in.CommonSpec
+	in.Pruner.DeepCopyInto(&out.Pruner)
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TektonPrunerSpec.
+func (in *TektonPrunerSpec) DeepCopy() *TektonPrunerSpec {
+	if in == nil {
+		return nil
+	}
+	out := new(TektonPrunerSpec)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *TektonPrunerStatus) DeepCopyInto(out *TektonPrunerStatus) {
+	*out = *in
+	in.Status.DeepCopyInto(&out.Status)
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TektonPrunerStatus.
+func (in *TektonPrunerStatus) DeepCopy() *TektonPrunerStatus {
+	if in == nil {
+		return nil
+	}
+	out := new(TektonPrunerStatus)
+	in.DeepCopyInto(out)
+	return out
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *TektonResult) DeepCopyInto(out *TektonResult) {
 	*out = *in
diff --git a/pkg/client/clientset/versioned/typed/operator/v1alpha1/fake/fake_operator_client.go b/pkg/client/clientset/versioned/typed/operator/v1alpha1/fake/fake_operator_client.go
index a58de5c4c..351264779 100644
--- a/pkg/client/clientset/versioned/typed/operator/v1alpha1/fake/fake_operator_client.go
+++ b/pkg/client/clientset/versioned/typed/operator/v1alpha1/fake/fake_operator_client.go
@@ -64,6 +64,10 @@ func (c *FakeOperatorV1alpha1) TektonPipelines() v1alpha1.TektonPipelineInterfac
 	return &FakeTektonPipelines{c}
 }
 
+func (c *FakeOperatorV1alpha1) TektonPruners() v1alpha1.TektonPrunerInterface {
+	return &FakeTektonPruners{c}
+}
+
 func (c *FakeOperatorV1alpha1) TektonResults() v1alpha1.TektonResultInterface {
 	return &FakeTektonResults{c}
 }
diff --git a/pkg/client/clientset/versioned/typed/operator/v1alpha1/fake/fake_tektonpruner.go b/pkg/client/clientset/versioned/typed/operator/v1alpha1/fake/fake_tektonpruner.go
new file mode 100644
index 000000000..d638a67fd
--- /dev/null
+++ b/pkg/client/clientset/versioned/typed/operator/v1alpha1/fake/fake_tektonpruner.go
@@ -0,0 +1,132 @@
+/*
+Copyright 2020 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by client-gen. DO NOT EDIT.
+
+package fake
+
+import (
+	"context"
+
+	v1alpha1 "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	labels "k8s.io/apimachinery/pkg/labels"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	testing "k8s.io/client-go/testing"
+)
+
+// FakeTektonPruners implements TektonPrunerInterface
+type FakeTektonPruners struct {
+	Fake *FakeOperatorV1alpha1
+}
+
+var tektonprunersResource = v1alpha1.SchemeGroupVersion.WithResource("tektonpruners")
+
+var tektonprunersKind = v1alpha1.SchemeGroupVersion.WithKind("TektonPruner")
+
+// Get takes name of the tektonPruner, and returns the corresponding tektonPruner object, and an error if there is any.
+func (c *FakeTektonPruners) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1alpha1.TektonPruner, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewRootGetAction(tektonprunersResource, name), &v1alpha1.TektonPruner{})
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.TektonPruner), err
+}
+
+// List takes label and field selectors, and returns the list of TektonPruners that match those selectors.
+func (c *FakeTektonPruners) List(ctx context.Context, opts v1.ListOptions) (result *v1alpha1.TektonPrunerList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewRootListAction(tektonprunersResource, tektonprunersKind, opts), &v1alpha1.TektonPrunerList{})
+	if obj == nil {
+		return nil, err
+	}
+
+	label, _, _ := testing.ExtractFromListOptions(opts)
+	if label == nil {
+		label = labels.Everything()
+	}
+	list := &v1alpha1.TektonPrunerList{ListMeta: obj.(*v1alpha1.TektonPrunerList).ListMeta}
+	for _, item := range obj.(*v1alpha1.TektonPrunerList).Items {
+		if label.Matches(labels.Set(item.Labels)) {
+			list.Items = append(list.Items, item)
+		}
+	}
+	return list, err
+}
+
+// Watch returns a watch.Interface that watches the requested tektonPruners.
+func (c *FakeTektonPruners) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
+	return c.Fake.
+		InvokesWatch(testing.NewRootWatchAction(tektonprunersResource, opts))
+}
+
+// Create takes the representation of a tektonPruner and creates it.  Returns the server's representation of the tektonPruner, and an error, if there is any.
+func (c *FakeTektonPruners) Create(ctx context.Context, tektonPruner *v1alpha1.TektonPruner, opts v1.CreateOptions) (result *v1alpha1.TektonPruner, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewRootCreateAction(tektonprunersResource, tektonPruner), &v1alpha1.TektonPruner{})
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.TektonPruner), err
+}
+
+// Update takes the representation of a tektonPruner and updates it. Returns the server's representation of the tektonPruner, and an error, if there is any.
+func (c *FakeTektonPruners) Update(ctx context.Context, tektonPruner *v1alpha1.TektonPruner, opts v1.UpdateOptions) (result *v1alpha1.TektonPruner, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewRootUpdateAction(tektonprunersResource, tektonPruner), &v1alpha1.TektonPruner{})
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.TektonPruner), err
+}
+
+// UpdateStatus was generated because the type contains a Status member.
+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
+func (c *FakeTektonPruners) UpdateStatus(ctx context.Context, tektonPruner *v1alpha1.TektonPruner, opts v1.UpdateOptions) (*v1alpha1.TektonPruner, error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewRootUpdateSubresourceAction(tektonprunersResource, "status", tektonPruner), &v1alpha1.TektonPruner{})
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.TektonPruner), err
+}
+
+// Delete takes name of the tektonPruner and deletes it. Returns an error if one occurs.
+func (c *FakeTektonPruners) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
+	_, err := c.Fake.
+		Invokes(testing.NewRootDeleteActionWithOptions(tektonprunersResource, name, opts), &v1alpha1.TektonPruner{})
+	return err
+}
+
+// DeleteCollection deletes a collection of objects.
+func (c *FakeTektonPruners) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
+	action := testing.NewRootDeleteCollectionAction(tektonprunersResource, listOpts)
+
+	_, err := c.Fake.Invokes(action, &v1alpha1.TektonPrunerList{})
+	return err
+}
+
+// Patch applies the patch and returns the patched tektonPruner.
+func (c *FakeTektonPruners) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.TektonPruner, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewRootPatchSubresourceAction(tektonprunersResource, name, pt, data, subresources...), &v1alpha1.TektonPruner{})
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha1.TektonPruner), err
+}
diff --git a/pkg/client/clientset/versioned/typed/operator/v1alpha1/generated_expansion.go b/pkg/client/clientset/versioned/typed/operator/v1alpha1/generated_expansion.go
index 10a81f28a..eefbedb4f 100644
--- a/pkg/client/clientset/versioned/typed/operator/v1alpha1/generated_expansion.go
+++ b/pkg/client/clientset/versioned/typed/operator/v1alpha1/generated_expansion.go
@@ -36,6 +36,8 @@ type TektonInstallerSetExpansion interface{}
 
 type TektonPipelineExpansion interface{}
 
+type TektonPrunerExpansion interface{}
+
 type TektonResultExpansion interface{}
 
 type TektonTriggerExpansion interface{}
diff --git a/pkg/client/clientset/versioned/typed/operator/v1alpha1/operator_client.go b/pkg/client/clientset/versioned/typed/operator/v1alpha1/operator_client.go
index 10a876342..b12fac167 100644
--- a/pkg/client/clientset/versioned/typed/operator/v1alpha1/operator_client.go
+++ b/pkg/client/clientset/versioned/typed/operator/v1alpha1/operator_client.go
@@ -37,6 +37,7 @@ type OperatorV1alpha1Interface interface {
 	TektonHubsGetter
 	TektonInstallerSetsGetter
 	TektonPipelinesGetter
+	TektonPrunersGetter
 	TektonResultsGetter
 	TektonTriggersGetter
 }
@@ -82,6 +83,10 @@ func (c *OperatorV1alpha1Client) TektonPipelines() TektonPipelineInterface {
 	return newTektonPipelines(c)
 }
 
+func (c *OperatorV1alpha1Client) TektonPruners() TektonPrunerInterface {
+	return newTektonPruners(c)
+}
+
 func (c *OperatorV1alpha1Client) TektonResults() TektonResultInterface {
 	return newTektonResults(c)
 }
diff --git a/pkg/client/clientset/versioned/typed/operator/v1alpha1/tektonpruner.go b/pkg/client/clientset/versioned/typed/operator/v1alpha1/tektonpruner.go
new file mode 100644
index 000000000..bed9fd60d
--- /dev/null
+++ b/pkg/client/clientset/versioned/typed/operator/v1alpha1/tektonpruner.go
@@ -0,0 +1,184 @@
+/*
+Copyright 2020 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by client-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	"context"
+	"time"
+
+	v1alpha1 "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
+	scheme "github.com/tektoncd/operator/pkg/client/clientset/versioned/scheme"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	rest "k8s.io/client-go/rest"
+)
+
+// TektonPrunersGetter has a method to return a TektonPrunerInterface.
+// A group's client should implement this interface.
+type TektonPrunersGetter interface {
+	TektonPruners() TektonPrunerInterface
+}
+
+// TektonPrunerInterface has methods to work with TektonPruner resources.
+type TektonPrunerInterface interface {
+	Create(ctx context.Context, tektonPruner *v1alpha1.TektonPruner, opts v1.CreateOptions) (*v1alpha1.TektonPruner, error)
+	Update(ctx context.Context, tektonPruner *v1alpha1.TektonPruner, opts v1.UpdateOptions) (*v1alpha1.TektonPruner, error)
+	UpdateStatus(ctx context.Context, tektonPruner *v1alpha1.TektonPruner, opts v1.UpdateOptions) (*v1alpha1.TektonPruner, error)
+	Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
+	DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
+	Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.TektonPruner, error)
+	List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.TektonPrunerList, error)
+	Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
+	Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.TektonPruner, err error)
+	TektonPrunerExpansion
+}
+
+// tektonPruners implements TektonPrunerInterface
+type tektonPruners struct {
+	client rest.Interface
+}
+
+// newTektonPruners returns a TektonPruners
+func newTektonPruners(c *OperatorV1alpha1Client) *tektonPruners {
+	return &tektonPruners{
+		client: c.RESTClient(),
+	}
+}
+
+// Get takes name of the tektonPruner, and returns the corresponding tektonPruner object, and an error if there is any.
+func (c *tektonPruners) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1alpha1.TektonPruner, err error) {
+	result = &v1alpha1.TektonPruner{}
+	err = c.client.Get().
+		Resource("tektonpruners").
+		Name(name).
+		VersionedParams(&options, scheme.ParameterCodec).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// List takes label and field selectors, and returns the list of TektonPruners that match those selectors.
+func (c *tektonPruners) List(ctx context.Context, opts v1.ListOptions) (result *v1alpha1.TektonPrunerList, err error) {
+	var timeout time.Duration
+	if opts.TimeoutSeconds != nil {
+		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
+	}
+	result = &v1alpha1.TektonPrunerList{}
+	err = c.client.Get().
+		Resource("tektonpruners").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Watch returns a watch.Interface that watches the requested tektonPruners.
+func (c *tektonPruners) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
+	var timeout time.Duration
+	if opts.TimeoutSeconds != nil {
+		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
+	}
+	opts.Watch = true
+	return c.client.Get().
+		Resource("tektonpruners").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Watch(ctx)
+}
+
+// Create takes the representation of a tektonPruner and creates it.  Returns the server's representation of the tektonPruner, and an error, if there is any.
+func (c *tektonPruners) Create(ctx context.Context, tektonPruner *v1alpha1.TektonPruner, opts v1.CreateOptions) (result *v1alpha1.TektonPruner, err error) {
+	result = &v1alpha1.TektonPruner{}
+	err = c.client.Post().
+		Resource("tektonpruners").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(tektonPruner).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Update takes the representation of a tektonPruner and updates it. Returns the server's representation of the tektonPruner, and an error, if there is any.
+func (c *tektonPruners) Update(ctx context.Context, tektonPruner *v1alpha1.TektonPruner, opts v1.UpdateOptions) (result *v1alpha1.TektonPruner, err error) {
+	result = &v1alpha1.TektonPruner{}
+	err = c.client.Put().
+		Resource("tektonpruners").
+		Name(tektonPruner.Name).
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(tektonPruner).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// UpdateStatus was generated because the type contains a Status member.
+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
+func (c *tektonPruners) UpdateStatus(ctx context.Context, tektonPruner *v1alpha1.TektonPruner, opts v1.UpdateOptions) (result *v1alpha1.TektonPruner, err error) {
+	result = &v1alpha1.TektonPruner{}
+	err = c.client.Put().
+		Resource("tektonpruners").
+		Name(tektonPruner.Name).
+		SubResource("status").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(tektonPruner).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Delete takes name of the tektonPruner and deletes it. Returns an error if one occurs.
+func (c *tektonPruners) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
+	return c.client.Delete().
+		Resource("tektonpruners").
+		Name(name).
+		Body(&opts).
+		Do(ctx).
+		Error()
+}
+
+// DeleteCollection deletes a collection of objects.
+func (c *tektonPruners) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
+	var timeout time.Duration
+	if listOpts.TimeoutSeconds != nil {
+		timeout = time.Duration(*listOpts.TimeoutSeconds) * time.Second
+	}
+	return c.client.Delete().
+		Resource("tektonpruners").
+		VersionedParams(&listOpts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Body(&opts).
+		Do(ctx).
+		Error()
+}
+
+// Patch applies the patch and returns the patched tektonPruner.
+func (c *tektonPruners) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.TektonPruner, err error) {
+	result = &v1alpha1.TektonPruner{}
+	err = c.client.Patch(pt).
+		Resource("tektonpruners").
+		Name(name).
+		SubResource(subresources...).
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(data).
+		Do(ctx).
+		Into(result)
+	return
+}
diff --git a/pkg/client/informers/externalversions/generic.go b/pkg/client/informers/externalversions/generic.go
index f59772960..0fab60d0a 100644
--- a/pkg/client/informers/externalversions/generic.go
+++ b/pkg/client/informers/externalversions/generic.go
@@ -71,6 +71,8 @@ func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource
 		return &genericInformer{resource: resource.GroupResource(), informer: f.Operator().V1alpha1().TektonInstallerSets().Informer()}, nil
 	case v1alpha1.SchemeGroupVersion.WithResource("tektonpipelines"):
 		return &genericInformer{resource: resource.GroupResource(), informer: f.Operator().V1alpha1().TektonPipelines().Informer()}, nil
+	case v1alpha1.SchemeGroupVersion.WithResource("tektonpruners"):
+		return &genericInformer{resource: resource.GroupResource(), informer: f.Operator().V1alpha1().TektonPruners().Informer()}, nil
 	case v1alpha1.SchemeGroupVersion.WithResource("tektonresults"):
 		return &genericInformer{resource: resource.GroupResource(), informer: f.Operator().V1alpha1().TektonResults().Informer()}, nil
 	case v1alpha1.SchemeGroupVersion.WithResource("tektontriggers"):
diff --git a/pkg/client/informers/externalversions/operator/v1alpha1/interface.go b/pkg/client/informers/externalversions/operator/v1alpha1/interface.go
index ea0576a98..9079fde7e 100644
--- a/pkg/client/informers/externalversions/operator/v1alpha1/interface.go
+++ b/pkg/client/informers/externalversions/operator/v1alpha1/interface.go
@@ -42,6 +42,8 @@ type Interface interface {
 	TektonInstallerSets() TektonInstallerSetInformer
 	// TektonPipelines returns a TektonPipelineInformer.
 	TektonPipelines() TektonPipelineInformer
+	// TektonPruners returns a TektonPrunerInformer.
+	TektonPruners() TektonPrunerInformer
 	// TektonResults returns a TektonResultInformer.
 	TektonResults() TektonResultInformer
 	// TektonTriggers returns a TektonTriggerInformer.
@@ -104,6 +106,11 @@ func (v *version) TektonPipelines() TektonPipelineInformer {
 	return &tektonPipelineInformer{factory: v.factory, tweakListOptions: v.tweakListOptions}
 }
 
+// TektonPruners returns a TektonPrunerInformer.
+func (v *version) TektonPruners() TektonPrunerInformer {
+	return &tektonPrunerInformer{factory: v.factory, tweakListOptions: v.tweakListOptions}
+}
+
 // TektonResults returns a TektonResultInformer.
 func (v *version) TektonResults() TektonResultInformer {
 	return &tektonResultInformer{factory: v.factory, tweakListOptions: v.tweakListOptions}
diff --git a/pkg/client/informers/externalversions/operator/v1alpha1/tektonpruner.go b/pkg/client/informers/externalversions/operator/v1alpha1/tektonpruner.go
new file mode 100644
index 000000000..b1be4e6a4
--- /dev/null
+++ b/pkg/client/informers/externalversions/operator/v1alpha1/tektonpruner.go
@@ -0,0 +1,89 @@
+/*
+Copyright 2020 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by informer-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	"context"
+	time "time"
+
+	operatorv1alpha1 "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
+	versioned "github.com/tektoncd/operator/pkg/client/clientset/versioned"
+	internalinterfaces "github.com/tektoncd/operator/pkg/client/informers/externalversions/internalinterfaces"
+	v1alpha1 "github.com/tektoncd/operator/pkg/client/listers/operator/v1alpha1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	runtime "k8s.io/apimachinery/pkg/runtime"
+	watch "k8s.io/apimachinery/pkg/watch"
+	cache "k8s.io/client-go/tools/cache"
+)
+
+// TektonPrunerInformer provides access to a shared informer and lister for
+// TektonPruners.
+type TektonPrunerInformer interface {
+	Informer() cache.SharedIndexInformer
+	Lister() v1alpha1.TektonPrunerLister
+}
+
+type tektonPrunerInformer struct {
+	factory          internalinterfaces.SharedInformerFactory
+	tweakListOptions internalinterfaces.TweakListOptionsFunc
+}
+
+// NewTektonPrunerInformer constructs a new informer for TektonPruner type.
+// Always prefer using an informer factory to get a shared informer instead of getting an independent
+// one. This reduces memory footprint and number of connections to the server.
+func NewTektonPrunerInformer(client versioned.Interface, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer {
+	return NewFilteredTektonPrunerInformer(client, resyncPeriod, indexers, nil)
+}
+
+// NewFilteredTektonPrunerInformer constructs a new informer for TektonPruner type.
+// Always prefer using an informer factory to get a shared informer instead of getting an independent
+// one. This reduces memory footprint and number of connections to the server.
+func NewFilteredTektonPrunerInformer(client versioned.Interface, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {
+	return cache.NewSharedIndexInformer(
+		&cache.ListWatch{
+			ListFunc: func(options v1.ListOptions) (runtime.Object, error) {
+				if tweakListOptions != nil {
+					tweakListOptions(&options)
+				}
+				return client.OperatorV1alpha1().TektonPruners().List(context.TODO(), options)
+			},
+			WatchFunc: func(options v1.ListOptions) (watch.Interface, error) {
+				if tweakListOptions != nil {
+					tweakListOptions(&options)
+				}
+				return client.OperatorV1alpha1().TektonPruners().Watch(context.TODO(), options)
+			},
+		},
+		&operatorv1alpha1.TektonPruner{},
+		resyncPeriod,
+		indexers,
+	)
+}
+
+func (f *tektonPrunerInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer {
+	return NewFilteredTektonPrunerInformer(client, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
+}
+
+func (f *tektonPrunerInformer) Informer() cache.SharedIndexInformer {
+	return f.factory.InformerFor(&operatorv1alpha1.TektonPruner{}, f.defaultInformer)
+}
+
+func (f *tektonPrunerInformer) Lister() v1alpha1.TektonPrunerLister {
+	return v1alpha1.NewTektonPrunerLister(f.Informer().GetIndexer())
+}
diff --git a/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/fake/fake.go b/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/fake/fake.go
new file mode 100644
index 000000000..e453ec905
--- /dev/null
+++ b/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/fake/fake.go
@@ -0,0 +1,40 @@
+/*
+Copyright 2020 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by injection-gen. DO NOT EDIT.
+
+package fake
+
+import (
+	context "context"
+
+	fake "github.com/tektoncd/operator/pkg/client/injection/informers/factory/fake"
+	tektonpruner "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpruner"
+	controller "knative.dev/pkg/controller"
+	injection "knative.dev/pkg/injection"
+)
+
+var Get = tektonpruner.Get
+
+func init() {
+	injection.Fake.RegisterInformer(withInformer)
+}
+
+func withInformer(ctx context.Context) (context.Context, controller.Informer) {
+	f := fake.Get(ctx)
+	inf := f.Operator().V1alpha1().TektonPruners()
+	return context.WithValue(ctx, tektonpruner.Key{}, inf), inf.Informer()
+}
diff --git a/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/filtered/fake/fake.go b/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/filtered/fake/fake.go
new file mode 100644
index 000000000..0bd90e01b
--- /dev/null
+++ b/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/filtered/fake/fake.go
@@ -0,0 +1,52 @@
+/*
+Copyright 2020 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by injection-gen. DO NOT EDIT.
+
+package fake
+
+import (
+	context "context"
+
+	factoryfiltered "github.com/tektoncd/operator/pkg/client/injection/informers/factory/filtered"
+	filtered "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/filtered"
+	controller "knative.dev/pkg/controller"
+	injection "knative.dev/pkg/injection"
+	logging "knative.dev/pkg/logging"
+)
+
+var Get = filtered.Get
+
+func init() {
+	injection.Fake.RegisterFilteredInformers(withInformer)
+}
+
+func withInformer(ctx context.Context) (context.Context, []controller.Informer) {
+	untyped := ctx.Value(factoryfiltered.LabelKey{})
+	if untyped == nil {
+		logging.FromContext(ctx).Panic(
+			"Unable to fetch labelkey from context.")
+	}
+	labelSelectors := untyped.([]string)
+	infs := []controller.Informer{}
+	for _, selector := range labelSelectors {
+		f := factoryfiltered.Get(ctx, selector)
+		inf := f.Operator().V1alpha1().TektonPruners()
+		ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
+		infs = append(infs, inf.Informer())
+	}
+	return ctx, infs
+}
diff --git a/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/filtered/tektonpruner.go b/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/filtered/tektonpruner.go
new file mode 100644
index 000000000..d6e915c78
--- /dev/null
+++ b/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/filtered/tektonpruner.go
@@ -0,0 +1,65 @@
+/*
+Copyright 2020 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by injection-gen. DO NOT EDIT.
+
+package filtered
+
+import (
+	context "context"
+
+	v1alpha1 "github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1"
+	filtered "github.com/tektoncd/operator/pkg/client/injection/informers/factory/filtered"
+	controller "knative.dev/pkg/controller"
+	injection "knative.dev/pkg/injection"
+	logging "knative.dev/pkg/logging"
+)
+
+func init() {
+	injection.Default.RegisterFilteredInformers(withInformer)
+}
+
+// Key is used for associating the Informer inside the context.Context.
+type Key struct {
+	Selector string
+}
+
+func withInformer(ctx context.Context) (context.Context, []controller.Informer) {
+	untyped := ctx.Value(filtered.LabelKey{})
+	if untyped == nil {
+		logging.FromContext(ctx).Panic(
+			"Unable to fetch labelkey from context.")
+	}
+	labelSelectors := untyped.([]string)
+	infs := []controller.Informer{}
+	for _, selector := range labelSelectors {
+		f := filtered.Get(ctx, selector)
+		inf := f.Operator().V1alpha1().TektonPruners()
+		ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
+		infs = append(infs, inf.Informer())
+	}
+	return ctx, infs
+}
+
+// Get extracts the typed informer from the context.
+func Get(ctx context.Context, selector string) v1alpha1.TektonPrunerInformer {
+	untyped := ctx.Value(Key{Selector: selector})
+	if untyped == nil {
+		logging.FromContext(ctx).Panicf(
+			"Unable to fetch github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1.TektonPrunerInformer with selector %s from context.", selector)
+	}
+	return untyped.(v1alpha1.TektonPrunerInformer)
+}
diff --git a/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/tektonpruner.go b/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/tektonpruner.go
new file mode 100644
index 000000000..29dfe236b
--- /dev/null
+++ b/pkg/client/injection/informers/operator/v1alpha1/tektonpruner/tektonpruner.go
@@ -0,0 +1,52 @@
+/*
+Copyright 2020 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by injection-gen. DO NOT EDIT.
+
+package tektonpruner
+
+import (
+	context "context"
+
+	v1alpha1 "github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1"
+	factory "github.com/tektoncd/operator/pkg/client/injection/informers/factory"
+	controller "knative.dev/pkg/controller"
+	injection "knative.dev/pkg/injection"
+	logging "knative.dev/pkg/logging"
+)
+
+func init() {
+	injection.Default.RegisterInformer(withInformer)
+}
+
+// Key is used for associating the Informer inside the context.Context.
+type Key struct{}
+
+func withInformer(ctx context.Context) (context.Context, controller.Informer) {
+	f := factory.Get(ctx)
+	inf := f.Operator().V1alpha1().TektonPruners()
+	return context.WithValue(ctx, Key{}, inf), inf.Informer()
+}
+
+// Get extracts the typed informer from the context.
+func Get(ctx context.Context) v1alpha1.TektonPrunerInformer {
+	untyped := ctx.Value(Key{})
+	if untyped == nil {
+		logging.FromContext(ctx).Panic(
+			"Unable to fetch github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1.TektonPrunerInformer from context.")
+	}
+	return untyped.(v1alpha1.TektonPrunerInformer)
+}
diff --git a/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner/controller.go b/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner/controller.go
new file mode 100644
index 000000000..fe7eb66d4
--- /dev/null
+++ b/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner/controller.go
@@ -0,0 +1,170 @@
+/*
+Copyright 2020 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by injection-gen. DO NOT EDIT.
+
+package tektonpruner
+
+import (
+	context "context"
+	fmt "fmt"
+	reflect "reflect"
+	strings "strings"
+
+	versionedscheme "github.com/tektoncd/operator/pkg/client/clientset/versioned/scheme"
+	client "github.com/tektoncd/operator/pkg/client/injection/client"
+	tektonpruner "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpruner"
+	zap "go.uber.org/zap"
+	corev1 "k8s.io/api/core/v1"
+	labels "k8s.io/apimachinery/pkg/labels"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	scheme "k8s.io/client-go/kubernetes/scheme"
+	v1 "k8s.io/client-go/kubernetes/typed/core/v1"
+	record "k8s.io/client-go/tools/record"
+	kubeclient "knative.dev/pkg/client/injection/kube/client"
+	controller "knative.dev/pkg/controller"
+	logging "knative.dev/pkg/logging"
+	logkey "knative.dev/pkg/logging/logkey"
+	reconciler "knative.dev/pkg/reconciler"
+)
+
+const (
+	defaultControllerAgentName = "tektonpruner-controller"
+	defaultFinalizerName       = "tektonpruners.operator.tekton.dev"
+)
+
+// NewImpl returns a controller.Impl that handles queuing and feeding work from
+// the queue through an implementation of controller.Reconciler, delegating to
+// the provided Interface and optional Finalizer methods. OptionsFn is used to return
+// controller.ControllerOptions to be used by the internal reconciler.
+func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl {
+	logger := logging.FromContext(ctx)
+
+	// Check the options function input. It should be 0 or 1.
+	if len(optionsFns) > 1 {
+		logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
+	}
+
+	tektonprunerInformer := tektonpruner.Get(ctx)
+
+	lister := tektonprunerInformer.Lister()
+
+	var promoteFilterFunc func(obj interface{}) bool
+	var promoteFunc = func(bkt reconciler.Bucket) {}
+
+	rec := &reconcilerImpl{
+		LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
+			PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error {
+
+				// Signal promotion event
+				promoteFunc(bkt)
+
+				all, err := lister.List(labels.Everything())
+				if err != nil {
+					return err
+				}
+				for _, elt := range all {
+					if promoteFilterFunc != nil {
+						if ok := promoteFilterFunc(elt); !ok {
+							continue
+						}
+					}
+					enq(bkt, types.NamespacedName{
+						Namespace: elt.GetNamespace(),
+						Name:      elt.GetName(),
+					})
+				}
+				return nil
+			},
+		},
+		Client:        client.Get(ctx),
+		Lister:        lister,
+		reconciler:    r,
+		finalizerName: defaultFinalizerName,
+	}
+
+	ctrType := reflect.TypeOf(r).Elem()
+	ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
+	ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")
+
+	logger = logger.With(
+		zap.String(logkey.ControllerType, ctrTypeName),
+		zap.String(logkey.Kind, "operator.tekton.dev.TektonPruner"),
+	)
+
+	impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
+	agentName := defaultControllerAgentName
+
+	// Pass impl to the options. Save any optional results.
+	for _, fn := range optionsFns {
+		opts := fn(impl)
+		if opts.ConfigStore != nil {
+			rec.configStore = opts.ConfigStore
+		}
+		if opts.FinalizerName != "" {
+			rec.finalizerName = opts.FinalizerName
+		}
+		if opts.AgentName != "" {
+			agentName = opts.AgentName
+		}
+		if opts.SkipStatusUpdates {
+			rec.skipStatusUpdates = true
+		}
+		if opts.DemoteFunc != nil {
+			rec.DemoteFunc = opts.DemoteFunc
+		}
+		if opts.PromoteFilterFunc != nil {
+			promoteFilterFunc = opts.PromoteFilterFunc
+		}
+		if opts.PromoteFunc != nil {
+			promoteFunc = opts.PromoteFunc
+		}
+	}
+
+	rec.Recorder = createRecorder(ctx, agentName)
+
+	return impl
+}
+
+func createRecorder(ctx context.Context, agentName string) record.EventRecorder {
+	logger := logging.FromContext(ctx)
+
+	recorder := controller.GetEventRecorder(ctx)
+	if recorder == nil {
+		// Create event broadcaster
+		logger.Debug("Creating event broadcaster")
+		eventBroadcaster := record.NewBroadcaster()
+		watches := []watch.Interface{
+			eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
+			eventBroadcaster.StartRecordingToSink(
+				&v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
+		}
+		recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
+		go func() {
+			<-ctx.Done()
+			for _, w := range watches {
+				w.Stop()
+			}
+		}()
+	}
+
+	return recorder
+}
+
+func init() {
+	versionedscheme.AddToScheme(scheme.Scheme)
+}
diff --git a/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner/reconciler.go b/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner/reconciler.go
new file mode 100644
index 000000000..e94def601
--- /dev/null
+++ b/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner/reconciler.go
@@ -0,0 +1,432 @@
+/*
+Copyright 2020 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by injection-gen. DO NOT EDIT.
+
+package tektonpruner
+
+import (
+	context "context"
+	json "encoding/json"
+	fmt "fmt"
+
+	v1alpha1 "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
+	versioned "github.com/tektoncd/operator/pkg/client/clientset/versioned"
+	operatorv1alpha1 "github.com/tektoncd/operator/pkg/client/listers/operator/v1alpha1"
+	zap "go.uber.org/zap"
+	"go.uber.org/zap/zapcore"
+	v1 "k8s.io/api/core/v1"
+	equality "k8s.io/apimachinery/pkg/api/equality"
+	errors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	labels "k8s.io/apimachinery/pkg/labels"
+	types "k8s.io/apimachinery/pkg/types"
+	sets "k8s.io/apimachinery/pkg/util/sets"
+	record "k8s.io/client-go/tools/record"
+	controller "knative.dev/pkg/controller"
+	kmp "knative.dev/pkg/kmp"
+	logging "knative.dev/pkg/logging"
+	reconciler "knative.dev/pkg/reconciler"
+)
+
+// Interface defines the strongly typed interfaces to be implemented by a
+// controller reconciling v1alpha1.TektonPruner.
+type Interface interface {
+	// ReconcileKind implements custom logic to reconcile v1alpha1.TektonPruner. Any changes
+	// to the objects .Status or .Finalizers will be propagated to the stored
+	// object. It is recommended that implementors do not call any update calls
+	// for the Kind inside of ReconcileKind, it is the responsibility of the calling
+	// controller to propagate those properties. The resource passed to ReconcileKind
+	// will always have an empty deletion timestamp.
+	ReconcileKind(ctx context.Context, o *v1alpha1.TektonPruner) reconciler.Event
+}
+
+// Finalizer defines the strongly typed interfaces to be implemented by a
+// controller finalizing v1alpha1.TektonPruner.
+type Finalizer interface {
+	// FinalizeKind implements custom logic to finalize v1alpha1.TektonPruner. Any changes
+	// to the objects .Status or .Finalizers will be ignored. Returning a nil or
+	// Normal type reconciler.Event will allow the finalizer to be deleted on
+	// the resource. The resource passed to FinalizeKind will always have a set
+	// deletion timestamp.
+	FinalizeKind(ctx context.Context, o *v1alpha1.TektonPruner) reconciler.Event
+}
+
+// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
+// controller reconciling v1alpha1.TektonPruner if they want to process resources for which
+// they are not the leader.
+type ReadOnlyInterface interface {
+	// ObserveKind implements logic to observe v1alpha1.TektonPruner.
+	// This method should not write to the API.
+	ObserveKind(ctx context.Context, o *v1alpha1.TektonPruner) reconciler.Event
+}
+
+type doReconcile func(ctx context.Context, o *v1alpha1.TektonPruner) reconciler.Event
+
+// reconcilerImpl implements controller.Reconciler for v1alpha1.TektonPruner resources.
+type reconcilerImpl struct {
+	// LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
+	reconciler.LeaderAwareFuncs
+
+	// Client is used to write back status updates.
+	Client versioned.Interface
+
+	// Listers index properties about resources.
+	Lister operatorv1alpha1.TektonPrunerLister
+
+	// Recorder is an event recorder for recording Event resources to the
+	// Kubernetes API.
+	Recorder record.EventRecorder
+
+	// configStore allows for decorating a context with config maps.
+	// +optional
+	configStore reconciler.ConfigStore
+
+	// reconciler is the implementation of the business logic of the resource.
+	reconciler Interface
+
+	// finalizerName is the name of the finalizer to reconcile.
+	finalizerName string
+
+	// skipStatusUpdates configures whether or not this reconciler automatically updates
+	// the status of the reconciled resource.
+	skipStatusUpdates bool
+}
+
+// Check that our Reconciler implements controller.Reconciler.
+var _ controller.Reconciler = (*reconcilerImpl)(nil)
+
+// Check that our generated Reconciler is always LeaderAware.
+var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)
+
+func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister operatorv1alpha1.TektonPrunerLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler {
+	// Check the options function input. It should be 0 or 1.
+	if len(options) > 1 {
+		logger.Fatal("Up to one options struct is supported, found: ", len(options))
+	}
+
+	// Fail fast when users inadvertently implement the other LeaderAware interface.
+	// For the typed reconcilers, Promote shouldn't take any arguments.
+	if _, ok := r.(reconciler.LeaderAware); ok {
+		logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
+	}
+
+	rec := &reconcilerImpl{
+		LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
+			PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error {
+				all, err := lister.List(labels.Everything())
+				if err != nil {
+					return err
+				}
+				for _, elt := range all {
+					// TODO: Consider letting users specify a filter in options.
+					enq(bkt, types.NamespacedName{
+						Namespace: elt.GetNamespace(),
+						Name:      elt.GetName(),
+					})
+				}
+				return nil
+			},
+		},
+		Client:        client,
+		Lister:        lister,
+		Recorder:      recorder,
+		reconciler:    r,
+		finalizerName: defaultFinalizerName,
+	}
+
+	for _, opts := range options {
+		if opts.ConfigStore != nil {
+			rec.configStore = opts.ConfigStore
+		}
+		if opts.FinalizerName != "" {
+			rec.finalizerName = opts.FinalizerName
+		}
+		if opts.SkipStatusUpdates {
+			rec.skipStatusUpdates = true
+		}
+		if opts.DemoteFunc != nil {
+			rec.DemoteFunc = opts.DemoteFunc
+		}
+	}
+
+	return rec
+}
+
+// Reconcile implements controller.Reconciler
+func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error {
+	logger := logging.FromContext(ctx)
+
+	// Initialize the reconciler state. This will convert the namespace/name
+	// string into a distinct namespace and name, determine if this instance of
+	// the reconciler is the leader, and any additional interfaces implemented
+	// by the reconciler. Returns an error is the resource key is invalid.
+	s, err := newState(key, r)
+	if err != nil {
+		logger.Error("Invalid resource key: ", key)
+		return nil
+	}
+
+	// If we are not the leader, and we don't implement either ReadOnly
+	// observer interfaces, then take a fast-path out.
+	if s.isNotLeaderNorObserver() {
+		return controller.NewSkipKey(key)
+	}
+
+	// If configStore is set, attach the frozen configuration to the context.
+	if r.configStore != nil {
+		ctx = r.configStore.ToContext(ctx)
+	}
+
+	// Add the recorder to context.
+	ctx = controller.WithEventRecorder(ctx, r.Recorder)
+
+	// Get the resource with this namespace/name.
+
+	getter := r.Lister
+
+	original, err := getter.Get(s.name)
+
+	if errors.IsNotFound(err) {
+		// The resource may no longer exist, in which case we stop processing and call
+		// the ObserveDeletion handler if appropriate.
+		logger.Debugf("Resource %q no longer exists", key)
+		if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok {
+			return del.ObserveDeletion(ctx, types.NamespacedName{
+				Namespace: s.namespace,
+				Name:      s.name,
+			})
+		}
+		return nil
+	} else if err != nil {
+		return err
+	}
+
+	// Don't modify the informers copy.
+	resource := original.DeepCopy()
+
+	var reconcileEvent reconciler.Event
+
+	name, do := s.reconcileMethodFor(resource)
+	// Append the target method to the logger.
+	logger = logger.With(zap.String("targetMethod", name))
+	switch name {
+	case reconciler.DoReconcileKind:
+		// Set and update the finalizer on resource if r.reconciler
+		// implements Finalizer.
+		if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil {
+			return fmt.Errorf("failed to set finalizers: %w", err)
+		}
+
+		// Reconcile this copy of the resource and then write back any status
+		// updates regardless of whether the reconciliation errored out.
+		reconcileEvent = do(ctx, resource)
+
+	case reconciler.DoFinalizeKind:
+		// For finalizing reconcilers, if this resource being marked for deletion
+		// and reconciled cleanly (nil or normal event), remove the finalizer.
+		reconcileEvent = do(ctx, resource)
+
+		if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil {
+			return fmt.Errorf("failed to clear finalizers: %w", err)
+		}
+
+	case reconciler.DoObserveKind:
+		// Observe any changes to this resource, since we are not the leader.
+		reconcileEvent = do(ctx, resource)
+
+	}
+
+	// Synchronize the status.
+	switch {
+	case r.skipStatusUpdates:
+		// This reconciler implementation is configured to skip resource updates.
+		// This may mean this reconciler does not observe spec, but reconciles external changes.
+	case equality.Semantic.DeepEqual(original.Status, resource.Status):
+		// If we didn't change anything then don't call updateStatus.
+		// This is important because the copy we loaded from the injectionInformer's
+		// cache may be stale and we don't want to overwrite a prior update
+		// to status with this stale state.
+	case !s.isLeader:
+		// High-availability reconcilers may have many replicas watching the resource, but only
+		// the elected leader is expected to write modifications.
+		logger.Warn("Saw status changes when we aren't the leader!")
+	default:
+		if err = r.updateStatus(ctx, logger, original, resource); err != nil {
+			logger.Warnw("Failed to update resource status", zap.Error(err))
+			r.Recorder.Eventf(resource, v1.EventTypeWarning, "UpdateFailed",
+				"Failed to update status for %q: %v", resource.Name, err)
+			return err
+		}
+	}
+
+	// Report the reconciler event, if any.
+	if reconcileEvent != nil {
+		var event *reconciler.ReconcilerEvent
+		if reconciler.EventAs(reconcileEvent, &event) {
+			logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
+			r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())
+
+			// the event was wrapped inside an error, consider the reconciliation as failed
+			if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent {
+				return reconcileEvent
+			}
+			return nil
+		}
+
+		if controller.IsSkipKey(reconcileEvent) {
+			// This is a wrapped error, don't emit an event.
+		} else if ok, _ := controller.IsRequeueKey(reconcileEvent); ok {
+			// This is a wrapped error, don't emit an event.
+		} else {
+			logger.Errorw("Returned an error", zap.Error(reconcileEvent))
+			r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
+		}
+		return reconcileEvent
+	}
+
+	return nil
+}
+
+func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1alpha1.TektonPruner, desired *v1alpha1.TektonPruner) error {
+	existing = existing.DeepCopy()
+	return reconciler.RetryUpdateConflicts(func(attempts int) (err error) {
+		// The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
+		if attempts > 0 {
+
+			getter := r.Client.OperatorV1alpha1().TektonPruners()
+
+			existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
+			if err != nil {
+				return err
+			}
+		}
+
+		// If there's nothing to update, just return.
+		if equality.Semantic.DeepEqual(existing.Status, desired.Status) {
+			return nil
+		}
+
+		if logger.Desugar().Core().Enabled(zapcore.DebugLevel) {
+			if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil && diff != "" {
+				logger.Debug("Updating status with: ", diff)
+			}
+		}
+
+		existing.Status = desired.Status
+
+		updater := r.Client.OperatorV1alpha1().TektonPruners()
+
+		_, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
+		return err
+	})
+}
+
+// updateFinalizersFiltered will update the Finalizers of the resource.
+// TODO: this method could be generic and sync all finalizers. For now it only
+// updates defaultFinalizerName or its override.
+func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1alpha1.TektonPruner, desiredFinalizers sets.Set[string]) (*v1alpha1.TektonPruner, error) {
+	// Don't modify the informers copy.
+	existing := resource.DeepCopy()
+
+	var finalizers []string
+
+	// If there's nothing to update, just return.
+	existingFinalizers := sets.New[string](existing.Finalizers...)
+
+	if desiredFinalizers.Has(r.finalizerName) {
+		if existingFinalizers.Has(r.finalizerName) {
+			// Nothing to do.
+			return resource, nil
+		}
+		// Add the finalizer.
+		finalizers = append(existing.Finalizers, r.finalizerName)
+	} else {
+		if !existingFinalizers.Has(r.finalizerName) {
+			// Nothing to do.
+			return resource, nil
+		}
+		// Remove the finalizer.
+		existingFinalizers.Delete(r.finalizerName)
+		finalizers = sets.List(existingFinalizers)
+	}
+
+	mergePatch := map[string]interface{}{
+		"metadata": map[string]interface{}{
+			"finalizers":      finalizers,
+			"resourceVersion": existing.ResourceVersion,
+		},
+	}
+
+	patch, err := json.Marshal(mergePatch)
+	if err != nil {
+		return resource, err
+	}
+
+	patcher := r.Client.OperatorV1alpha1().TektonPruners()
+
+	resourceName := resource.Name
+	updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
+	if err != nil {
+		r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
+			"Failed to update finalizers for %q: %v", resourceName, err)
+	} else {
+		r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
+			"Updated %q finalizers", resource.GetName())
+	}
+	return updated, err
+}
+
+func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1alpha1.TektonPruner) (*v1alpha1.TektonPruner, error) {
+	if _, ok := r.reconciler.(Finalizer); !ok {
+		return resource, nil
+	}
+
+	finalizers := sets.New[string](resource.Finalizers...)
+
+	// If this resource is not being deleted, mark the finalizer.
+	if resource.GetDeletionTimestamp().IsZero() {
+		finalizers.Insert(r.finalizerName)
+	}
+
+	// Synchronize the finalizers filtered by r.finalizerName.
+	return r.updateFinalizersFiltered(ctx, resource, finalizers)
+}
+
+func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1alpha1.TektonPruner, reconcileEvent reconciler.Event) (*v1alpha1.TektonPruner, error) {
+	if _, ok := r.reconciler.(Finalizer); !ok {
+		return resource, nil
+	}
+	if resource.GetDeletionTimestamp().IsZero() {
+		return resource, nil
+	}
+
+	finalizers := sets.New[string](resource.Finalizers...)
+
+	if reconcileEvent != nil {
+		var event *reconciler.ReconcilerEvent
+		if reconciler.EventAs(reconcileEvent, &event) {
+			if event.EventType == v1.EventTypeNormal {
+				finalizers.Delete(r.finalizerName)
+			}
+		}
+	} else {
+		finalizers.Delete(r.finalizerName)
+	}
+
+	// Synchronize the finalizers filtered by r.finalizerName.
+	return r.updateFinalizersFiltered(ctx, resource, finalizers)
+}
diff --git a/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner/state.go b/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner/state.go
new file mode 100644
index 000000000..1766a9d16
--- /dev/null
+++ b/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner/state.go
@@ -0,0 +1,97 @@
+/*
+Copyright 2020 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by injection-gen. DO NOT EDIT.
+
+package tektonpruner
+
+import (
+	fmt "fmt"
+
+	v1alpha1 "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
+	types "k8s.io/apimachinery/pkg/types"
+	cache "k8s.io/client-go/tools/cache"
+	reconciler "knative.dev/pkg/reconciler"
+)
+
+// state is used to track the state of a reconciler in a single run.
+type state struct {
+	// key is the original reconciliation key from the queue.
+	key string
+	// namespace is the namespace split from the reconciliation key.
+	namespace string
+	// name is the name split from the reconciliation key.
+	name string
+	// reconciler is the reconciler.
+	reconciler Interface
+	// roi is the read only interface cast of the reconciler.
+	roi ReadOnlyInterface
+	// isROI (Read Only Interface) the reconciler only observes reconciliation.
+	isROI bool
+	// isLeader the instance of the reconciler is the elected leader.
+	isLeader bool
+}
+
+func newState(key string, r *reconcilerImpl) (*state, error) {
+	// Convert the namespace/name string into a distinct namespace and name.
+	namespace, name, err := cache.SplitMetaNamespaceKey(key)
+	if err != nil {
+		return nil, fmt.Errorf("invalid resource key: %s", key)
+	}
+
+	roi, isROI := r.reconciler.(ReadOnlyInterface)
+
+	isLeader := r.IsLeaderFor(types.NamespacedName{
+		Namespace: namespace,
+		Name:      name,
+	})
+
+	return &state{
+		key:        key,
+		namespace:  namespace,
+		name:       name,
+		reconciler: r.reconciler,
+		roi:        roi,
+		isROI:      isROI,
+		isLeader:   isLeader,
+	}, nil
+}
+
+// isNotLeaderNorObserver checks to see if this reconciler with the current
+// state is enabled to do any work or not.
+// isNotLeaderNorObserver returns true when there is no work possible for the
+// reconciler.
+func (s *state) isNotLeaderNorObserver() bool {
+	if !s.isLeader && !s.isROI {
+		// If we are not the leader, and we don't implement the ReadOnly
+		// interface, then take a fast-path out.
+		return true
+	}
+	return false
+}
+
+func (s *state) reconcileMethodFor(o *v1alpha1.TektonPruner) (string, doReconcile) {
+	if o.GetDeletionTimestamp().IsZero() {
+		if s.isLeader {
+			return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
+		} else if s.isROI {
+			return reconciler.DoObserveKind, s.roi.ObserveKind
+		}
+	} else if fin, ok := s.reconciler.(Finalizer); s.isLeader && ok {
+		return reconciler.DoFinalizeKind, fin.FinalizeKind
+	}
+	return "unknown", nil
+}
diff --git a/pkg/client/listers/operator/v1alpha1/expansion_generated.go b/pkg/client/listers/operator/v1alpha1/expansion_generated.go
index 5e56a4af3..0b3063658 100644
--- a/pkg/client/listers/operator/v1alpha1/expansion_generated.go
+++ b/pkg/client/listers/operator/v1alpha1/expansion_generated.go
@@ -54,6 +54,10 @@ type TektonInstallerSetListerExpansion interface{}
 // TektonPipelineLister.
 type TektonPipelineListerExpansion interface{}
 
+// TektonPrunerListerExpansion allows custom methods to be added to
+// TektonPrunerLister.
+type TektonPrunerListerExpansion interface{}
+
 // TektonResultListerExpansion allows custom methods to be added to
 // TektonResultLister.
 type TektonResultListerExpansion interface{}
diff --git a/pkg/client/listers/operator/v1alpha1/tektonpruner.go b/pkg/client/listers/operator/v1alpha1/tektonpruner.go
new file mode 100644
index 000000000..96133fd0f
--- /dev/null
+++ b/pkg/client/listers/operator/v1alpha1/tektonpruner.go
@@ -0,0 +1,68 @@
+/*
+Copyright 2020 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+// Code generated by lister-gen. DO NOT EDIT.
+
+package v1alpha1
+
+import (
+	v1alpha1 "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
+	"k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/labels"
+	"k8s.io/client-go/tools/cache"
+)
+
+// TektonPrunerLister helps list TektonPruners.
+// All objects returned here must be treated as read-only.
+type TektonPrunerLister interface {
+	// List lists all TektonPruners in the indexer.
+	// Objects returned here must be treated as read-only.
+	List(selector labels.Selector) (ret []*v1alpha1.TektonPruner, err error)
+	// Get retrieves the TektonPruner from the index for a given name.
+	// Objects returned here must be treated as read-only.
+	Get(name string) (*v1alpha1.TektonPruner, error)
+	TektonPrunerListerExpansion
+}
+
+// tektonPrunerLister implements the TektonPrunerLister interface.
+type tektonPrunerLister struct {
+	indexer cache.Indexer
+}
+
+// NewTektonPrunerLister returns a new TektonPrunerLister.
+func NewTektonPrunerLister(indexer cache.Indexer) TektonPrunerLister {
+	return &tektonPrunerLister{indexer: indexer}
+}
+
+// List lists all TektonPruners in the indexer.
+func (s *tektonPrunerLister) List(selector labels.Selector) (ret []*v1alpha1.TektonPruner, err error) {
+	err = cache.ListAll(s.indexer, selector, func(m interface{}) {
+		ret = append(ret, m.(*v1alpha1.TektonPruner))
+	})
+	return ret, err
+}
+
+// Get retrieves the TektonPruner from the index for a given name.
+func (s *tektonPrunerLister) Get(name string) (*v1alpha1.TektonPruner, error) {
+	obj, exists, err := s.indexer.GetByKey(name)
+	if err != nil {
+		return nil, err
+	}
+	if !exists {
+		return nil, errors.NewNotFound(v1alpha1.Resource("tektonpruner"), name)
+	}
+	return obj.(*v1alpha1.TektonPruner), nil
+}
diff --git a/pkg/reconciler/common/initcontroller.go b/pkg/reconciler/common/initcontroller.go
index 31beefacc..9ed011e45 100644
--- a/pkg/reconciler/common/initcontroller.go
+++ b/pkg/reconciler/common/initcontroller.go
@@ -121,6 +121,9 @@ func (ctrl Controller) fetchSourceManifests(ctx context.Context, opts PayloadOpt
 	case "manual-approval-gate":
 		var mag v1alpha1.ManualApprovalGate
 		return AppendTarget(ctx, ctrl.Manifest, &mag)
+	case "tekton-pruner":
+		var pruner v1alpha1.TektonPruner
+		return AppendTarget(ctx, ctrl.Manifest, &pruner)
 	}
 
 	return nil
diff --git a/pkg/reconciler/common/releases.go b/pkg/reconciler/common/releases.go
index 37f0eda9f..59ab29e86 100644
--- a/pkg/reconciler/common/releases.go
+++ b/pkg/reconciler/common/releases.go
@@ -84,6 +84,8 @@ func ComponentDir(instance v1alpha1.TektonComponent) string {
 		return filepath.Join(koDataDir, "tekton-chains")
 	case *v1alpha1.ManualApprovalGate:
 		return filepath.Join(koDataDir, "manual-approval-gate")
+	case *v1alpha1.TektonPruner:
+		return filepath.Join(koDataDir, "tekton-pruner")
 	}
 	return ""
 }
diff --git a/pkg/reconciler/common/transformers.go b/pkg/reconciler/common/transformers.go
index 0e7c72f76..b32c73be5 100644
--- a/pkg/reconciler/common/transformers.go
+++ b/pkg/reconciler/common/transformers.go
@@ -47,6 +47,7 @@ const (
 	PacImagePrefix                = "IMAGE_PAC_"
 	ChainsImagePrefix             = "IMAGE_CHAINS_"
 	ManualApprovalGatePrefix      = "IMAGE_MAG_"
+	PrunerImagePrefix             = "IMAGE_PRUNER_"
 	ResultsImagePrefix            = "IMAGE_RESULTS_"
 	HubImagePrefix                = "IMAGE_HUB_"
 	DashboardImagePrefix          = "IMAGE_DASHBOARD_"
diff --git a/pkg/reconciler/kubernetes/kubernetesplatform/config.go b/pkg/reconciler/kubernetes/kubernetesplatform/config.go
index a8e8cc9bf..991046ec6 100644
--- a/pkg/reconciler/kubernetes/kubernetesplatform/config.go
+++ b/pkg/reconciler/kubernetes/kubernetesplatform/config.go
@@ -24,6 +24,7 @@ import (
 	k8sHub "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonhub"
 	k8sInstallerSet "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset"
 	k8sPipeline "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpipeline"
+	k8sTektonPruner "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpruner"
 	k8sResult "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonresult"
 	k8sTrigger "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektontrigger"
 	"github.com/tektoncd/operator/pkg/reconciler/platform"
@@ -61,6 +62,9 @@ var (
 		platform.ControllerManualApprovalGate: injection.NamedControllerConstructor{
 			Name:                  string(platform.ControllerManualApprovalGate),
 			ControllerConstructor: k8sManualApprovalGate.NewController},
+		platform.ControllerTektonPruner: injection.NamedControllerConstructor{
+			Name:                  string(platform.ControllerTektonPruner),
+			ControllerConstructor: k8sTektonPruner.NewController},
 		platform.ControllerTektonInstallerSet: injection.NamedControllerConstructor{
 			Name:                  string(platform.ControllerTektonInstallerSet),
 			ControllerConstructor: k8sInstallerSet.NewController},
diff --git a/pkg/reconciler/kubernetes/tektonpruner/controller.go b/pkg/reconciler/kubernetes/tektonpruner/controller.go
new file mode 100644
index 000000000..114aec876
--- /dev/null
+++ b/pkg/reconciler/kubernetes/tektonpruner/controller.go
@@ -0,0 +1,92 @@
+/*
+Copyright 2024 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package tektonpruner
+
+import (
+	"context"
+
+	"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
+	operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
+	tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
+	tektonPipelineinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline"
+	tektoncdprunerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpruner"
+	tektoncdprunerreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner"
+	"github.com/tektoncd/operator/pkg/reconciler/common"
+	"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
+	"k8s.io/client-go/tools/cache"
+	kubeclient "knative.dev/pkg/client/injection/kube/client"
+	"knative.dev/pkg/configmap"
+	"knative.dev/pkg/controller"
+	"knative.dev/pkg/injection"
+	"knative.dev/pkg/logging"
+)
+
+const versionConfigMap = "tekton-pruner-info"
+
+func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {
+	return NewExtendedController(common.NoExtension)(ctx, cmw)
+}
+
+func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor {
+	return func(ctx context.Context, w configmap.Watcher) *controller.Impl {
+		logger := logging.FromContext(ctx)
+
+		ctrl := common.Controller{
+			Logger:           logger,
+			VersionConfigMap: versionConfigMap,
+		}
+
+		manifest, ver := ctrl.InitController(ctx, common.PayloadOptions{})
+		if ver == common.ReleaseVersionUnknown {
+			ver = "devel"
+		}
+
+		operatorVer, err := common.OperatorVersion(ctx)
+		if err != nil {
+			logger.Fatal(err)
+		}
+
+		tisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()
+
+		c := &Reconciler{
+			operatorClientSet:   operatorclient.Get(ctx),
+			kubeClientSet:       kubeclient.Get(ctx),
+			extension:           generator(ctx),
+			manifest:            manifest,
+			installerSetClient:  client.NewInstallerSetClient(tisClient, operatorVer, ver, v1alpha1.KindTektonPruner, nil),
+			pipelineInformer:    tektonPipelineinformer.Get(ctx),
+			operatorVersion:     operatorVer,
+			tektonPrunerVersion: ver,
+		}
+		impl := tektoncdprunerreconciler.NewImpl(ctx, c)
+
+		logger.Info("Setting up event handlers for tektonpruner")
+
+		if _, err := tektoncdprunerinformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {
+			logger.Panicf("Couldn't register tektonpruner informer event handler: %w", err)
+		}
+
+		if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
+			FilterFunc: controller.FilterController(&v1alpha1.TektonPruner{}),
+			Handler:    controller.HandleAll(impl.EnqueueControllerOf),
+		}); err != nil {
+			logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
+		}
+
+		return impl
+	}
+}
diff --git a/pkg/reconciler/kubernetes/tektonpruner/finalizer.go b/pkg/reconciler/kubernetes/tektonpruner/finalizer.go
new file mode 100644
index 000000000..51ed15f94
--- /dev/null
+++ b/pkg/reconciler/kubernetes/tektonpruner/finalizer.go
@@ -0,0 +1,53 @@
+/*
+Copyright 2024 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package tektonpruner
+
+import (
+	"context"
+
+	mf "github.com/manifestival/manifestival"
+	"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
+	tektonpruner "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner"
+	"knative.dev/pkg/logging"
+	pkgreconciler "knative.dev/pkg/reconciler"
+)
+
+var _ tektonpruner.Finalizer = (*Reconciler)(nil)
+
+// FinalizeKind removes all resources after deletion of a ManualApprovalGate CR.
+func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonPruner) pkgreconciler.Event {
+	logger := logging.FromContext(ctx)
+
+	//Delete CRDs before deleting rest of resources so that any instance
+	//of CRDs which has finalizer set will get deleted before we remove
+	//the controller;s deployment for it
+	if err := r.manifest.Filter(mf.CRDs).Delete(); err != nil {
+		logger.Error("Failed to deleted CRDs for ManualApprovalGate")
+		return err
+	}
+
+	if err := r.installerSetClient.CleanupMainSet(ctx); err != nil {
+		logger.Error("failed to cleanup main installerset: ", err)
+		return err
+	}
+
+	if err := r.extension.Finalize(ctx, original); err != nil {
+		logger.Error("Failed to finalize platform resources", err)
+	}
+
+	return nil
+}
diff --git a/pkg/reconciler/kubernetes/tektonpruner/reconciler.go b/pkg/reconciler/kubernetes/tektonpruner/reconciler.go
new file mode 100644
index 000000000..70756c671
--- /dev/null
+++ b/pkg/reconciler/kubernetes/tektonpruner/reconciler.go
@@ -0,0 +1,134 @@
+/*
+Copyright 2024 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package tektonpruner
+
+import (
+	"context"
+	"fmt"
+
+	mf "github.com/manifestival/manifestival"
+	"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
+	clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
+	pipelineinformer "github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1"
+	tektonPrunerreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner"
+	"github.com/tektoncd/operator/pkg/reconciler/common"
+	"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
+	"k8s.io/client-go/kubernetes"
+	"knative.dev/pkg/logging"
+	pkgreconciler "knative.dev/pkg/reconciler"
+)
+
+type Reconciler struct {
+	// kube client to interact with core k8s resources
+	kubeClientSet kubernetes.Interface
+	// operatorClientSet allows us to configure operator objects
+	operatorClientSet clientset.Interface
+	// installer Set client to do CRUD operations for components
+	installerSetClient *client.InstallerSetClient
+	// manifest has the source manifest of tektonPruner for a
+	// particular version
+	manifest mf.Manifest
+	// Platform-specific behavior to affect the transform
+	extension common.Extension
+	// tektonPrunerVersion describes the current tektonPruner version
+	tektonPrunerVersion string
+	operatorVersion     string
+	// pipelineInformer provides access to a shared informer and lister for
+	// TektonPipelines
+	pipelineInformer pipelineinformer.TektonPipelineInformer
+}
+
+// Check that our Reconciler implements controller.Reconciler
+var _ tektonPrunerreconciler.Interface = (*Reconciler)(nil)
+
+func (r *Reconciler) ReconcileKind(ctx context.Context, pruner *v1alpha1.TektonPruner) pkgreconciler.Event {
+	logger := logging.FromContext(ctx).With("name", pruner.GetName())
+
+	pruner.Status.InitializeConditions()
+	pruner.Status.SetVersion(r.tektonPrunerVersion)
+
+	if pruner.GetName() != v1alpha1.PrunerResourceName {
+		msg := fmt.Sprintf("Resource ignored, Expected Name: %s, Got Name: %s",
+			v1alpha1.PrunerResourceName,
+			pruner.GetName(),
+		)
+		logger.Error(msg)
+		pruner.Status.MarkNotReady(msg)
+		return nil
+	}
+
+	// reconcile target namespace
+	if err := common.ReconcileTargetNamespace(ctx, nil, nil, pruner, r.kubeClientSet); err != nil {
+		return err
+	}
+
+	//Make sure TektonPipeline is installed before proceeding with
+	//tektonPruner
+	if _, err := common.PipelineReady(r.pipelineInformer); err != nil {
+		if err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR {
+			pruner.Status.MarkDependencyInstalling("tekton-pipelines is still installing")
+			// wait for pipeline status to change
+			return v1alpha1.REQUEUE_EVENT_AFTER
+		}
+		// (tektonpipeline.operator.tekton.dev instance not available yet)
+		pruner.Status.MarkDependencyMissing("tekton-pipelines does not exist")
+		return err
+	}
+	pruner.Status.MarkDependenciesInstalled()
+
+	if err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil {
+		logger.Error("failed to remove obsolete installer sets: %v", err)
+		return err
+	}
+
+	if err := r.extension.PreReconcile(ctx, pruner); err != nil {
+		msg := fmt.Sprintf("PreReconciliation failed: %s", err.Error())
+		logger.Error(msg)
+		if err == v1alpha1.REQUEUE_EVENT_AFTER {
+			return err
+		}
+		pruner.Status.MarkPreReconcilerFailed(msg)
+		return nil
+	}
+
+	pruner.Status.MarkPreReconcilerComplete()
+
+	if err := r.installerSetClient.MainSet(ctx, pruner, &r.manifest, filterAndTransform(r.extension)); err != nil {
+		msg := fmt.Sprintf("Main Reconcilation failed: %s", err.Error())
+		logger.Error(msg)
+		if err == v1alpha1.REQUEUE_EVENT_AFTER {
+			return err
+		}
+		pruner.Status.MarkInstallerSetNotReady(msg)
+		return nil
+	}
+
+	if err := r.extension.PostReconcile(ctx, pruner); err != nil {
+		msg := fmt.Sprintf("PostReconciliation failed: %s", err.Error())
+		logger.Error(msg)
+		if err == v1alpha1.REQUEUE_EVENT_AFTER {
+			return err
+		}
+		pruner.Status.MarkPostReconcilerFailed(msg)
+		return nil
+	}
+
+	// Mark PostReconcile Complete
+	pruner.Status.MarkPostReconcilerComplete()
+
+	return nil
+}
diff --git a/pkg/reconciler/kubernetes/tektonpruner/transformer.go b/pkg/reconciler/kubernetes/tektonpruner/transformer.go
new file mode 100644
index 000000000..d71351021
--- /dev/null
+++ b/pkg/reconciler/kubernetes/tektonpruner/transformer.go
@@ -0,0 +1,51 @@
+/*
+Copyright 2024 The Tekton Authors
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package tektonpruner
+
+import (
+	"context"
+
+	mf "github.com/manifestival/manifestival"
+	"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
+	"github.com/tektoncd/operator/pkg/reconciler/common"
+	"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
+)
+
+func filterAndTransform(extension common.Extension) client.FilterAndTransform {
+	return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {
+		prunerCR := comp.(*v1alpha1.TektonPruner)
+		prunerImages := common.ToLowerCaseKeys(common.ImagesFromEnv(common.PrunerImagePrefix))
+		extra := []mf.Transformer{
+			common.InjectOperandNameLabelOverwriteExisting(v1alpha1.PrunerResourceName),
+			common.DeploymentImages(prunerImages),
+			common.AddDeploymentRestrictedPSA(),
+		}
+		extra = append(extra, extension.Transformers(prunerCR)...)
+		err := common.Transform(ctx, manifest, prunerCR, extra...)
+		if err != nil {
+			return &mf.Manifest{}, err
+		}
+
+		// additional options transformer
+		// always execute as last transformer, so that the values in options will be final update values on the manifests
+		if err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, prunerCR.Spec.GetTargetNamespace(), prunerCR.Spec.Options); err != nil {
+			return &mf.Manifest{}, err
+		}
+
+		return manifest, nil
+	}
+}
diff --git a/pkg/reconciler/openshift/openshiftplatform/config.go b/pkg/reconciler/openshift/openshiftplatform/config.go
index a12b95703..b2f5c9116 100644
--- a/pkg/reconciler/openshift/openshiftplatform/config.go
+++ b/pkg/reconciler/openshift/openshiftplatform/config.go
@@ -82,5 +82,9 @@ var (
 			Name:                  string(platform.ControllerTektonInstallerSet),
 			ControllerConstructor: k8sInstallerSet.NewController,
 		},
+		platform.ControllerTektonPruner: injection.NamedControllerConstructor{
+			Name:                  string(platform.ControllerTektonPruner),
+			ControllerConstructor: k8sInstallerSet.NewController,
+		},
 	}
 )
diff --git a/pkg/reconciler/platform/const.go b/pkg/reconciler/platform/const.go
index 37ba5a00d..3b74ab25a 100644
--- a/pkg/reconciler/platform/const.go
+++ b/pkg/reconciler/platform/const.go
@@ -26,6 +26,7 @@ const (
 	ControllerTektonChain        ControllerName = "tektonchain"
 	ControllerTektonResult       ControllerName = "tektonresult"
 	ControllerManualApprovalGate ControllerName = "manualapprovalgate"
+	ControllerTektonPruner       ControllerName = "tektonpruner"
 	EnvControllerNames           string         = "CONTROLLER_NAMES"
 	EnvSharedMainName            string         = "UNIQUE_PROCESS_NAME"
 )
-- 
2.39.5 (Apple Git-154)

